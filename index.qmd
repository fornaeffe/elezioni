---
title: "Simulazione elezioni politiche"
author: "Luca Fornasari"
date: "`r Sys.Date()`"
format: 
  html:
    self-contained: true
---


<!-- 
Vedi il file README.md per info sul funzionamento di questi script e sui
dati di input.
-->

Questo report contiene i risultati di una simulazione delle prossime elezioni
della Camera dei Deputati e del Senato della Repubblica Italiana, ottenuti
partendo da un sondaggio politico e dai risultati delle precedenti elezioni. Da
questi vengono simulati i possibili voti presi da ciascuna lista in ciascun
collegio, e dai voti vengono poi calcolati il numero di eletti per ciascuna
lista.

Avverto che ho fatto questa simulazione per curiosità e non per lavoro, e che
potrebbero essermi sfuggiti degli errori nel processo di
simulazione, i risultati vanno dunque presi senza alcuna garanzia di
accuratezza.

Segnalazioni, richieste e suggerimenti a <fornaeffe@gmail.com> o sul repository
<https://github.com/fornaeffe/elezioni>.

```{r parametri}
#| include: false
variab <- 1

iterazioni <- 1000
```


```{r setup}
#| include: false
knitr::opts_chunk$set(echo = FALSE)

library(data.table)
library(stringr)
library(readxl)
library(parallel)
```

```{r distribuzione voti}
#| include: false
#| cache: true

#### Importazione dati ####

##### Base dati #####

base_dati <- read.csv2(
  "dati/BaseDati_Proposta_Commissione.csv",
  fileEncoding = "utf-8",

# TO DO: verificare che le righe seguenti siano davvero utili
  # colClasses = c(
  #   CIRCOCAM_20_DEN = "factor",
  #   CP20_DEN = "factor",
  #   CU20_DEN = "factor"
  # ),

  na.strings = ""
)

base_dati$SP20_DEN[base_dati$DEN_REG20 == "Trentino-Alto Adige"] <- 
  "Trentino-Alto Adige/Südtirol - P01"

base_dati$DEN_REG20[base_dati$DEN_REG20 == "Trentino-Alto Adige"] <- 
  "Trentino-Alto Adige/Südtirol"

base_dati$CIRCOCAM_20_DEN <- 
  str_remove(base_dati$CIRCOCAM_20_DEN, "/Vallée d'Aoste")
base_dati$SU20_DEN <- 
  str_remove(base_dati$SU20_DEN, "/Vallée d'Aoste")
base_dati$CU20_DEN <- 
  str_remove(base_dati$CU20_DEN, "/Vallée d'Aoste")

#Trasformo in maiuscolo per compatibilità con i dati dei candidati
base_dati$DEN_REG20 <- toupper(base_dati$DEN_REG20)
base_dati$CIRCOCAM_20_DEN <- toupper(base_dati$CIRCOCAM_20_DEN)
base_dati$CP20_DEN <- toupper(base_dati$CP20_DEN)
base_dati$SP20_DEN <- toupper(base_dati$SP20_DEN)
base_dati$CU20_DEN <- toupper(base_dati$CU20_DEN)
base_dati$SU20_DEN <- toupper(base_dati$SU20_DEN)


names(base_dati)[names(base_dati) == "DEN_PRO_CM20"] <- "PROVINCIA"
names(base_dati)[names(base_dati) == "DEN_COM20"] <- "COMUNE"

base_dati$PROVINCIA <- toupper(base_dati$PROVINCIA)
base_dati$COMUNE <- toupper(base_dati$COMUNE)

province <- aggregate(
  POP_2011 ~ PROVINCIA,
  base_dati,
  sum
)


comuni <- unique(base_dati[, c("PROVINCIA", "COMUNE")])

##### Politiche #####

camera_2018 <- read.csv2(
  "dati/2018/camera-20180304_2.txt",
  fileEncoding = "utf-8"
)

camera_2018$PROV_TEMP <- str_remove(camera_2018$COLLEGIOUNINOMINALE, "\\A[0-9]{2} (- )?")
camera_2018$PROV_TEMP <- str_remove(camera_2018$PROV_TEMP, " - .*\\Z")
camera_2018$PROV_TEMP <- str_remove(camera_2018$PROV_TEMP, " AREA STATISTICA .*\\Z")

camera_2018 <- merge(
  camera_2018,
  comuni,
  by.x = "PROV_TEMP",
  by.y = "COMUNE",
  all.x = TRUE
)

camera_2018$PROVINCIA[camera_2018$PROV_TEMP == ""] <- "AOSTA"
camera_2018$PROVINCIA[camera_2018$PROV_TEMP == "BOLZANO/BOZEN"] <- "BOLZANO"
camera_2018$PROVINCIA[camera_2018$PROV_TEMP == "BRESSANONE/BRIXEN"] <- "BOLZANO"
camera_2018$PROVINCIA[camera_2018$PROV_TEMP == "CANT+"] <- "COMO"
camera_2018$PROVINCIA[camera_2018$PROV_TEMP == "CORIGLIANO CALABRO"] <- "COSENZA"
camera_2018$PROVINCIA[camera_2018$PROV_TEMP == "FORL¦"] <- "FORLI'-CESENA"
camera_2018$PROVINCIA[camera_2018$PROV_TEMP == "MERANO/MERAN"] <- "BOLZANO"
camera_2018$PROVINCIA[camera_2018$PROV_TEMP == "NARDÊ"] <- "LECCE"
camera_2018$PROVINCIA[camera_2018$PROV_TEMP == "PATERNÊ"] <- "CATANIA"
camera_2018$PROVINCIA[camera_2018$PROV_TEMP == "SAN DONA' DI PIAVE"] <- "VENEZIA"

# Checks
# TO DO: trasformare in un controllo che innesca un errore
setdiff(unique(camera_2018$PROVINCIA), province$PROVINCIA)
sum(is.na(camera_2018$PROVINCIA))

##### Amministrative #####

lista_files <- list.files("dati/eur_reg")

lista_dataframes <- lapply(
  paste0("dati/eur_reg/", lista_files),
  read.csv2,
  fileEncoding = "utf-8"
)

lista_dataframes <- mapply(
  function(df, nome_file) {
    names(df) <- toupper(names(df))
    if (is.null(df$COGNOME)) df$COGNOME <- NA
    if (is.null(df$NOME)) df$NOME <- NA
    names(df)[names(df) == "VOTILISTA"] <- "VOTI_LISTA"
    df <- df[,c(
      "REGIONE",
      "PROVINCIA",
      "COMUNE",
      "ELETTORI",
      "VOTANTI",
      "COGNOME",
      "NOME",
      "LISTA",
      "VOTI_LISTA"
    )]
    df$ELEZIONE <- nome_file
    df
  },
  df = lista_dataframes,
  nome_file = lista_files,
  SIMPLIFY = FALSE
)

amministrative <- rbindlist(lista_dataframes)
lista_dataframes <- NULL

amministrative$PROVINCIA[amministrative$PROVINCIA == "REGGIO NELL' EMILIA"] <- "REGGIO NELL'EMILIA"
amministrative$PROVINCIA[amministrative$PROVINCIA == "MASSA-CARRARA"] <- "MASSA CARRARA"

# Checks
# TO DO: trasformare in un controllo che innesca un errore
setdiff(unique(amministrative$PROVINCIA), province$PROVINCIA)

##### Unione camera e amministrative #####

camera_2018$REGIONE <- str_remove(camera_2018$CIRCOSCRIZIONE, " [0-9]\\Z")
camera_2018$REGIONE <- str_remove(camera_2018$REGIONE, "/.*")
camera_2018$ELEZIONE <- "camera_2018"

###### Calcolo astensione ######

camera_2018_astensione <- aggregate(
  VOTI_LISTA ~ 
    CIRCOSCRIZIONE +
    COLLEGIOPLURINOMINALE +
    COLLEGIOUNINOMINALE +
    REGIONE +
    PROVINCIA +
    COMUNE +
    ELETTORI +
    VOTANTI + 
    ELEZIONE,
  camera_2018,
  sum
)

camera_2018_astensione$LISTA <- "astensione"
camera_2018_astensione$COGNOME <- NA
camera_2018_astensione$NOME <- NA
camera_2018_astensione$VOTI_LISTA <- 
  camera_2018_astensione$ELETTORI - camera_2018_astensione$VOTI_LISTA

amministrative_astensione <- aggregate(
  VOTI_LISTA ~ 
    REGIONE +
    PROVINCIA +
    COMUNE +
    ELETTORI +
    VOTANTI +
    ELEZIONE,
  amministrative,
  sum
)

amministrative_astensione$LISTA <- "astensione"
amministrative_astensione$COGNOME <- NA
amministrative_astensione$NOME <- NA
amministrative_astensione$VOTI_LISTA <- 
  amministrative_astensione$ELETTORI - amministrative_astensione$VOTI_LISTA

dati_precedenti <- rbind(
  amministrative,
  amministrative_astensione,
  camera_2018[, c(
    "REGIONE",
    "PROVINCIA",
    "COMUNE",
    "ELETTORI",
    "VOTANTI",
    "COGNOME",
    "NOME",
    "LISTA",
    "VOTI_LISTA",
    "ELEZIONE"
  )],
  camera_2018_astensione[, c(
    "REGIONE",
    "PROVINCIA",
    "COMUNE",
    "ELETTORI",
    "VOTANTI",
    "COGNOME",
    "NOME",
    "LISTA",
    "VOTI_LISTA",
    "ELEZIONE"
  )]
)
amministrative <- NULL
camera_2018 <- NULL


# Questo è servito per esportare i nomi delle liste
write.csv2(
  dati_precedenti[!duplicated(dati_precedenti$LISTA), ],
  "_output/liste_precedenti_elezioni.csv",
  fileEncoding = "utf-8"
)

##### Corrispondenza liste - aree #####

liste <- read_xlsx("dati/liste_precedenti_elezioni.xlsx", "liste")
liste <- liste[
  !duplicated(liste$LISTA) & !is.na(liste$LISTA) & !is.na(liste$AREA)
  , c("LISTA", "AREA")]


#### Calcolo distribuzione spaziale elettori di area ####

dati_precedenti$AREA <- 
  factor(dati_precedenti$LISTA, levels = liste$LISTA, labels = liste$AREA)

prov_area <- aggregate(
  VOTI_LISTA ~ PROVINCIA + AREA,
  dati_precedenti,
  sum
)

prov_area <- merge(
  prov_area,
  aggregate(
    VOTI_LISTA ~ PROVINCIA,
    prov_area,
    sum
  ),
  by = "PROVINCIA",
  suffixes = c("", "_TOT")
)

prov_area$PERCENTUALE_STORICA <- prov_area$VOTI_LISTA / prov_area$VOTI_LISTA_TOT

prov_area <- merge(
  prov_area,
  province
)

prov_area$POP_AREA <- prov_area$PERCENTUALE_STORICA * prov_area$POP_2011

aree <- aggregate(
  POP_AREA ~ AREA,
  prov_area,
  sum
)

prov_area <- merge(
  prov_area,
  aree,
  by = "AREA",
  suffixes = c("", "_TOT")
)

prov_area$PERCENTUALE_AREA <- prov_area$POP_AREA / prov_area$POP_AREA_TOT

# Calcolo popolazione nazionale
popolazione <- sum(province$POP_2011)

```

```{r collegi}

prepara_collegi <- function(ramo) {
  if (ramo == "camera") {
    colonna_circ <- base_dati$CIRCOCAM_20_DEN
    colonna_pluri <- base_dati$CP20_DEN
    colonna_uni <- base_dati$CU20_DEN
  }
  
  if (ramo == "senato") {
    colonna_circ <- base_dati$DEN_REG20
    colonna_pluri <- base_dati$SP20_DEN
    colonna_uni <- base_dati$SU20_DEN
  }
  
  dati <- list()
  
  # Estraggo le circoscrizioni
  dati$circoscrizioni <- aggregate(
    POP_2011 ~ colonna_circ,
    base_dati,
    sum
  )
  
  # Estraggo i collegi plurinominali
  dati$collegi_pluri <- aggregate(
    POP_2011 ~ colonna_circ + colonna_pluri,
    base_dati,
    sum
  )
  
  dati$collegi_uni <- aggregate(
    POP_2011 ~ colonna_circ + colonna_pluri + colonna_uni,
    base_dati,
    sum
  )
  
  
  ##### Rinomino le colonne ####
  names(dati$circoscrizioni)[1] <- "CIRCOSCRIZIONE"
  names(dati$collegi_pluri)[1] <- "CIRCOSCRIZIONE"
  names(dati$collegi_pluri)[2] <- "COLLEGIOPLURINOMINALE"
  names(dati$collegi_uni)[1] <- "CIRCOSCRIZIONE"
  names(dati$collegi_uni)[2] <- "COLLEGIOPLURINOMINALE"
  names(dati$collegi_uni)[3] <- "COLLEGIOUNINOMINALE"
  
  # Carico i collegi
  dati$collegi_pluri <- merge(
    dati$collegi_pluri,
    read_xlsx("dati/2022/collegi.xlsx", paste0(ramo, "_pluri"))
  )
  
  dati
}

# Preparo le liste
camera <- prepara_collegi("camera")
senato <- prepara_collegi("senato")


```

```{r dati}
#| include: false
#| cache: true

# Importo liste_naz

liste_naz <- read_xlsx("dati/2022/liste.xlsx", "liste")
altri_dati <- read_xlsx("dati/2022/liste.xlsx", "altri_dati")

# liste_naz$ALTRE <- FALSE
# 
# manca <- 1 - sum(liste_naz$PERCENTUALE)
# liste_da_aggiungere <- manca * 100 %/% 1
# 
# for (i in 1:liste_da_aggiungere) {
#   liste_naz <- rbind(
#     liste_naz,
#     data.frame(
#       LISTA = paste("Altra", i),
#       ABBREV = paste("Altra", i),
#       PERCENTUALE = manca / liste_da_aggiungere,
#       COALIZIONE = NA,
#       MINORANZA = FALSE,
#       COLORE = NA,
#       AREA = "ALTRI",
#       ALTRE = TRUE
#     )
#   )
# }

liste_naz$CL <- ifelse(
  is.na(liste_naz$COALIZIONE), 
  liste_naz$ABBREV, 
  liste_naz$COALIZIONE
)

carica_dati <- function(ramo) {
  liste_uni <- read.csv(
    paste0(
      "dati/2022/",
      toupper(ramo),
      "_ITALIA_20220925_uni.csv"
    )
  )
  candidati_pluri <- read.csv(
    paste0(
      "dati/2022/",
      toupper(ramo),
      "_ITALIA_20220925_pluri.csv"
    )
  )
  
  names(liste_uni)[2:3] <- c("COLLEGIOUNINOMINALE", "LISTA")
  names(candidati_pluri)[2:3] <- c("COLLEGIOPLURINOMINALE", "LISTA")
  
  liste_uni$CANDIDATO <- trimws(liste_uni$CANDIDATO)
  candidati_pluri$CANDIDATO <- trimws(candidati_pluri$CANDIDATO)
  
  # Correggo la scrittura del SÜDTIROL
  liste_uni$CIRCOSCRIZIONE <- 
    str_replace(liste_uni$CIRCOSCRIZIONE, "S\\?DTIROL", "SÜDTIROL")
  liste_uni$COLLEGIOUNINOMINALE <- 
    str_replace(liste_uni$COLLEGIOUNINOMINALE, "S\\?DTIROL", "SÜDTIROL")
  candidati_pluri$CIRCOSCRIZIONE <- 
    str_replace(candidati_pluri$CIRCOSCRIZIONE, "S\\?DTIROL", "SÜDTIROL")
  candidati_pluri$COLLEGIOPLURINOMINALE <- 
    str_replace(candidati_pluri$COLLEGIOPLURINOMINALE, "S\\?DTIROL", "SÜDTIROL")
  
  # Correggo la circoscrizione "ITALIA"
  sost_circ <- function(stringa) {
    substr(stringa, 1, str_length(stringa) - 6)
  }
  
  liste_uni$CIRCOSCRIZIONE[liste_uni$CIRCOSCRIZIONE == "ITALIA"] <- 
    sapply(
      liste_uni$COLLEGIOUNINOMINALE[liste_uni$CIRCOSCRIZIONE == "ITALIA"],
      sost_circ
    )
  
  # Aggiungo i numeri dei candidati
  candidati_pluri$NUMERO <- ave(
    seq_along(candidati_pluri$CANDIDATO),
    paste(candidati_pluri$COLLEGIOPLURINOMINALE, candidati_pluri$LISTA),
    FUN = seq_along
  )
  
  # Aggiungo la colonna "collegio plurinominale"
  liste_uni <- merge(
    liste_uni,
    get(ramo)$collegi_uni
  )
  
  # Aggiungo le colonne "abbrev", "cl" e "area"
  liste_uni <- merge(
    liste_uni,
    liste_naz[, c("LISTA", "ABBREV", "CL", "AREA")]
  )
  
  # Aggiungo la colonna CL e ABBREV
  candidati_pluri <- merge(
    candidati_pluri,
    liste_naz[, c("LISTA", "CL", "ABBREV")]
  )
  
  # Tolgo i candidati di liste non considerate
  candidati_pluri <- 
    candidati_pluri[candidati_pluri$LISTA %in% liste_naz$LISTA, ]
  
  # Creo il dataframe candidati_uni
  candidati_uni <- unique(
    liste_uni[
      ,
      c(
        "CIRCOSCRIZIONE",
        "COLLEGIOPLURINOMINALE",
        "COLLEGIOUNINOMINALE",
        "CL",
        "CANDIDATO"
      )
    ]
  )
  
  ## Controllo omonimie
  
  # Omonimie uni
  omonimi_uni <- which(duplicated(candidati_uni$CANDIDATO))
  
  for (o in omonimi_uni) {
    vecchio_nome <- candidati_uni$CANDIDATO[o]
    cl <- candidati_uni$CL[o]
    nuovo_nome <- paste(vecchio_nome, cl, sep = " - ")
    
    candidati_uni$CANDIDATO[o] <- nuovo_nome
    candidati_pluri$CANDIDATO[
      candidati_pluri$CANDIDATO == vecchio_nome &
        candidati_pluri$CL == cl
    ] <- nuovo_nome
    liste_uni$CANDIDATO[
      liste_uni$CANDIDATO == vecchio_nome &
        liste_uni$CL == cl
    ] <- nuovo_nome
    
    message("Risolta omonimia uni: ", nuovo_nome)
  }
  
  # Omonimie pluri
  candidati_pluri_unico <- unique(
    candidati_pluri[, c("CANDIDATO", "ABBREV", "CL")]
  )
  omonimi_pluri <- which(duplicated(candidati_pluri_unico$CANDIDATO))
  
  for (o in omonimi_pluri) {
    vecchio_nome <- candidati_pluri_unico$CANDIDATO[o]
    abbrev <- candidati_pluri_unico$ABBREV[o]
    cl <- candidati_pluri_unico$CL[o]
    nuovo_nome <- paste(vecchio_nome, abbrev, sep = " - ")
    
    if (
      sum(
        candidati_uni$CANDIDATO == vecchio_nome & candidati_uni$CL == cl
      ) > 0 &
      sum(
        duplicated(
          candidati_pluri_unico$CL[
            candidati_pluri_unico$CANDIDATO == vecchio_nome
          ]
        )
      ) > 0
    ) {
      warning("C'è un candidato uninominale e due diversi candidati ",
              "plurinominali della coalizione ", 
              cl,
              " chiamati ",
              vecchio_nome,
              ", assegno il candidato uninominale al secondo dei due.")
    }
    
    candidati_pluri$CANDIDATO[
      candidati_pluri$CANDIDATO == vecchio_nome &
        candidati_pluri$ABBREV == abbrev
    ] <- nuovo_nome
    
    candidati_uni$CANDIDATO[
      candidati_uni$CANDIDATO == vecchio_nome &
        candidati_uni$CL == cl
    ] <- nuovo_nome
    
    liste_uni$CANDIDATO[
      liste_uni$CANDIDATO == vecchio_nome &
        liste_uni$CL == cl
    ] <- nuovo_nome
    
    message("Risolta omonimia pluri: ", nuovo_nome)
  }
  
  # Omonimie incrociate
  candidati_pluri_unico <- unique(
    candidati_pluri[, c("CANDIDATO", "ABBREV", "CL")]
  )
  candidati_tutti <- unique(rbind(
    candidati_uni[, c("CANDIDATO", "CL")],
    candidati_pluri_unico[, c("CANDIDATO", "CL")]
  ))
  omonimi_incrociati <- which(duplicated(candidati_tutti$CANDIDATO))
  
  for (o in omonimi_incrociati) {
    vecchio_nome <- candidati_tutti$CANDIDATO[o]
    cl <- candidati_tutti$CL[o]
    nuovo_nome <- paste(vecchio_nome, cl, sep = " - ")
    
    candidati_pluri$CANDIDATO[
      candidati_pluri$CANDIDATO == vecchio_nome &
        candidati_pluri$CL == cl
    ] <- nuovo_nome
    
    candidati_uni$CANDIDATO[
      candidati_uni$CANDIDATO == vecchio_nome &
        candidati_uni$CL == cl
    ] <- nuovo_nome
    
    liste_uni$CANDIDATO[
      liste_uni$CANDIDATO == vecchio_nome &
        liste_uni$CL == cl
    ] <- nuovo_nome
    
    message("Risolta omonimia incrociata: ", nuovo_nome)
  }
  
  list(
    liste_uni = liste_uni,
    candidati_uni = candidati_uni, 
    candidati_pluri = candidati_pluri
  )
}

camera <- c(camera, carica_dati("camera"))
senato <- c(senato, carica_dati("senato"))

# Check per controllare che i nomi corrispondano
setdiff(camera$candidati_uni$CIRCOSCRIZIONE, base_dati$CIRCOCAM_20_DEN)
setdiff(base_dati$CIRCOCAM_20_DEN, camera$candidati_uni$CIRCOSCRIZIONE)

setdiff(camera$candidati_pluri$CIRCOSCRIZIONE, base_dati$CIRCOCAM_20_DEN)
setdiff(base_dati$CIRCOCAM_20_DEN, camera$candidati_pluri$CIRCOSCRIZIONE)

setdiff(senato$candidati_uni$CIRCOSCRIZIONE, base_dati$DEN_REG20)
setdiff(base_dati$DEN_REG20, senato$candidati_uni$CIRCOSCRIZIONE)

setdiff(senato$candidati_pluri$CIRCOSCRIZIONE, base_dati$DEN_REG20)
setdiff(base_dati$DEN_REG20, senato$candidati_pluri$CIRCOSCRIZIONE)



setdiff(camera$candidati_uni$COLLEGIOUNINOMINALE, base_dati$CU20_DEN)
setdiff(base_dati$CU20_DEN, camera$candidati_uni$COLLEGIOUNINOMINALE)

setdiff(camera$candidati_pluri$COLLEGIOPLURINOMINALE, base_dati$CP20_DEN)
setdiff(base_dati$CP20_DEN, camera$candidati_pluri$COLLEGIOPLURINOMINALE)

setdiff(senato$candidati_uni$COLLEGIOUNINOMINALE, base_dati$SU20_DEN)
setdiff(base_dati$SU20_DEN, senato$candidati_uni$COLLEGIOUNINOMINALE)

setdiff(senato$candidati_pluri$COLLEGIOPLURINOMINALE, base_dati$SP20_DEN)
setdiff(base_dati$SP20_DEN, senato$candidati_pluri$COLLEGIOPLURINOMINALE)


```

```{r simula_perc_naz}

liste_sondaggi <- read_xlsx("dati/2022/liste.xlsx", "liste_sondaggi")

liste_naz <- merge(
  liste_naz,
  aggregate(
    PERCENTUALE ~ ABBREV,
    liste_sondaggi,
    function(x) mean(log(x))
  ),
  by = "ABBREV",
  all.x = TRUE,
  suffixes = c("", "_LOG")
)

liste_naz <- merge(
  liste_naz,
  aggregate(
    PERCENTUALE ~ ABBREV,
    liste_sondaggi,
    function(x) sd(log(x))
  ),
  by = "ABBREV",
  all.x = TRUE,
  suffixes = c("", "_LOG_SD")
)

tot_liste_conosciute <- sum(exp(liste_naz$PERCENTUALE_LOG), na.rm = TRUE)

if (tot_liste_conosciute < 1) {
  log_p_altre <- 
    log((1 - tot_liste_conosciute) / sum(is.na(liste_naz$PERCENTUALE_LOG)))
} else log_p_altre <- -10

liste_naz$PERCENTUALE_LOG[is.na(liste_naz$PERCENTUALE_LOG)] <- log_p_altre

liste_naz$PERCENTUALE_LOG_SD[is.na(liste_naz$PERCENTUALE_LOG_SD)] <- 1


```



```{r simula}
#| include: false
#| cache: true

#### Calcolo percentuali per provincia ####

liste_naz$PERC_CORRETTA <-liste_naz$PERCENTUALE * (1 - altri_dati$Astensione) 
liste_naz <- merge(
  liste_naz,
  data.frame(
    AREA = "astensione",
    PERC_CORRETTA = altri_dati$Astensione
  ),
  all = TRUE
)

aree <- merge(
  aree,
  aggregate(
    PERC_CORRETTA ~ AREA,
    liste_naz,
    sum
  )
)

names(aree)[names(aree) == "PERC_CORRETTA"] <- "PERCENTUALE"

aree$VOTANTI <- aree$PERCENTUALE * popolazione

prov_area <- merge(
  prov_area,
  aree[,c("AREA", "VOTANTI")]
)

prov_area$VOTANTI_LOCALI <- prov_area$VOTANTI * prov_area$PERCENTUALE_AREA

prov_area <- merge(
  prov_area,
  aggregate(
    VOTANTI_LOCALI ~ PROVINCIA,
    prov_area,
    sum
  ),
  by = "PROVINCIA",
  suffixes = c("", "_TOT")
)

prov_area$PERCENTUALE <- prov_area$VOTANTI_LOCALI / prov_area$VOTANTI_LOCALI_TOT

comuni_aree <- merge(
  base_dati,
  aree[c("AREA", "PERCENTUALE")]
)

comuni_aree <- merge(
  comuni_aree,
  prov_area[, c("PROVINCIA", "AREA", "PERCENTUALE")],
  all.x = TRUE,
  by = c("PROVINCIA", "AREA"),
  suffixes = c("", "_PROV")
)

comuni_aree$PERCENTUALE[!is.na(comuni_aree$PERCENTUALE_PROV)] <-
  comuni_aree$PERCENTUALE_PROV[!is.na(comuni_aree$PERCENTUALE_PROV)]

comuni_aree$VOTANTI <- 
  comuni_aree$POP_2011 * comuni_aree$PERCENTUALE

camera$aree_uni <- aggregate(
  cbind(VOTANTI, POP_2011) ~ CIRCOCAM_20_DEN + CP20_DEN + CU20_DEN + AREA,
  comuni_aree,
  sum
)

names(camera$aree_uni)[1] <- "CIRCOSCRIZIONE"
names(camera$aree_uni)[2] <- "COLLEGIOPLURINOMINALE"
names(camera$aree_uni)[3] <- "COLLEGIOUNINOMINALE"

senato$aree_uni <- aggregate(
  cbind(VOTANTI, POP_2011) ~ DEN_REG20 + SP20_DEN + SU20_DEN + AREA,
  comuni_aree,
  sum
)

names(senato$aree_uni)[1] <- "CIRCOSCRIZIONE"
names(senato$aree_uni)[2] <- "COLLEGIOPLURINOMINALE"
names(senato$aree_uni)[3] <- "COLLEGIOUNINOMINALE"

liste_naz <- merge(
  liste_naz,
  aree[, c("AREA", "PERCENTUALE")],
  by = "AREA",
  suffixes = c("", "_AREA")
)

liste_naz$PERC_IN_AREA <- liste_naz$PERC_CORRETTA / liste_naz$PERCENTUALE_AREA


simula <- function(
    ramo,
    iterazioni = 200,
    variab = .5
) {
  dati <- get(ramo)
  
  #### Preparo i data frame delle liste ai diversi livelli ####
  
  dati$liste_circ <- merge(
    dati$circoscrizioni,
    liste_naz[, c("LISTA", "PERCENTUALE")]
  )
  
  dati$liste_pluri <- merge(
    dati$collegi_pluri,
    dati$liste_circ[, c("CIRCOSCRIZIONE", "LISTA")]
  )
  
  # Aggiungo al dataframe liste_uni i dati sull'astensione
  astensione_uni <- merge(
    dati$collegi_uni,
    liste_naz[
      liste_naz$AREA == "astensione", 
      c("LISTA", "AREA", "ABBREV", "CL")
    ]
  )
  
  astensione_uni$CANDIDATO <- NA
  
  dati$liste_uni <- rbind(
    dati$liste_uni,
    astensione_uni
  )
  
  dati$liste_uni <- merge(
    dati$liste_uni,
    liste_naz[, c("LISTA", "AREA", "PERC_IN_AREA")]
  )
  
  dati$liste_uni <- merge(
    dati$liste_uni,
    dati$aree_uni[, c(
      "CIRCOSCRIZIONE",
      "COLLEGIOUNINOMINALE",
      "COLLEGIOPLURINOMINALE",
      "AREA",
      "VOTANTI"
    )]
  )
  
  dati$liste_uni$VOTANTI_LISTA_BASE <- 
    dati$liste_uni$VOTANTI * dati$liste_uni$PERC_IN_AREA
  
  dati$liste_uni <- merge(
    dati$liste_uni,
    aggregate(
      VOTANTI_LISTA_BASE ~ 
        CIRCOSCRIZIONE + COLLEGIOPLURINOMINALE + COLLEGIOUNINOMINALE,
      dati$liste_uni,
      sum
    ),
    by = c("CIRCOSCRIZIONE", "COLLEGIOPLURINOMINALE", "COLLEGIOUNINOMINALE"),
    suffixes = c("", "_TOT")
  )
  
  dati$liste_uni$PERC_LISTA_BASE <- 
    dati$liste_uni$VOTANTI_LISTA_BASE / dati$liste_uni$VOTANTI_LISTA_BASE_TOT
  
  dati$liste_uni$LOG_PERC_LISTA_BASE <- log(dati$liste_uni$PERC_LISTA_BASE)
  
  dati$liste_uni$CAND_MINORANZA <- FALSE
  dati$liste_uni$MINORANZA <- FALSE
  
  liste_naz <- liste_naz[!is.na(liste_naz$LISTA), ]
  
  
  iterazione <- function(
    iter = 1,
    ramo = "camera",
    liste_naz,
    dati,
    variab = .5
  ) {
    dati$liste_uni$LOG_P <- rnorm(
      dati$liste_uni$LOG_PERC_LISTA_BASE,
      dati$liste_uni$LOG_PERC_LISTA_BASE,
      variab
    )
    
    dati$liste_uni$PERCENTUALE_UNI <- ave(
      dati$liste_uni$LOG_P,
      paste(
        dati$liste_uni$CIRCOSCRIZIONE,
        dati$liste_uni$COLLEGIOPLURINOMINALE,
        dati$liste_uni$COLLEGIOUNINOMINALE
      ),
      FUN = function(x) exp(x) / sum(exp(x))
    )
    
    dati$liste_uni$VOTI_LISTA <- 
      dati$liste_uni$POP_2011 * dati$liste_uni$PERCENTUALE_UNI
    
    dati$liste_uni <- dati$liste_uni[!is.na(dati$liste_uni$LISTA), ]
    dati$liste_pluri <- dati$liste_pluri[!is.na(dati$liste_pluri$LISTA), ]
    dati$liste_circ <- dati$liste_circ[!is.na(dati$liste_circ$LISTA), ]
    
    dati$candidati_uni$DATA_NASCITA <- as.POSIXct("1990-01-01")
    
    # Calcolo i voti per candidato
    dati$candidati_uni <- merge(
      dati$candidati_uni,
      aggregate(
        VOTI_LISTA ~ 
          CIRCOSCRIZIONE +
          COLLEGIOPLURINOMINALE +
          COLLEGIOUNINOMINALE +
          CANDIDATO,
        dati$liste_uni,
        sum
      )
    )
    names(dati$candidati_uni)[names(dati$candidati_uni) == "VOTI_LISTA"] <-
      "VOTI_CANDIDATO"
    
    scrutinio <- Scrutinio(
      ramo,
      dati$liste_uni[, c(
        "CIRCOSCRIZIONE",
        "COLLEGIOPLURINOMINALE",
        "COLLEGIOUNINOMINALE",
        "CANDIDATO",
        "CAND_MINORANZA",
        "LISTA",
        "MINORANZA",
        "VOTI_LISTA"
      )],
      liste_naz[, c(
        "LISTA",
        "COALIZIONE",
        "MINORANZA"
      )],
      dati$candidati_uni[, c(
        "CIRCOSCRIZIONE",
        "COLLEGIOPLURINOMINALE",
        "COLLEGIOUNINOMINALE",
        "CANDIDATO",
        "DATA_NASCITA",
        "VOTI_CANDIDATO"
      )],
      dati$candidati_pluri[, c(
        "CIRCOSCRIZIONE",
        "COLLEGIOPLURINOMINALE",
        "LISTA",
        "NUMERO",
        "CANDIDATO"
      )],
      dati$collegi_pluri[, c(
        "CIRCOSCRIZIONE",
        "COLLEGIOPLURINOMINALE",
        "SEGGI"
      )],
      ifelse(ramo == "camera", 392, 196)
    )
    
    
    scrutinio$liste_pluri <- merge(
      scrutinio$liste_pluri,
      aggregate(
        VOTI_LISTA ~ CIRCOSCRIZIONE + COLLEGIOPLURINOMINALE + LISTA,
        dati$liste_uni,
        sum
      )
    )
    
    scrutinio$liste_pluri <- merge(
      scrutinio$liste_pluri,
      aggregate(
        VOTI_LISTA ~ CIRCOSCRIZIONE + COLLEGIOPLURINOMINALE,
        scrutinio$liste_pluri,
        sum
      ),
      by = c("CIRCOSCRIZIONE", "COLLEGIOPLURINOMINALE"),
      suffixes = c("", "_TOT")
    )
    
    scrutinio$liste_pluri <- merge(
      scrutinio$liste_pluri,
      liste_naz[, c("LISTA", "ABBREV")]
    )
    
    scrutinio$liste_pluri$PERCENTUALE <-
      scrutinio$liste_pluri$VOTI_LISTA / scrutinio$liste_pluri$VOTI_LISTA_TOT
    
    scrutinio$liste_naz <- aggregate(
      VOTI_LISTA ~ LISTA,
      scrutinio$liste_pluri,
      sum
    )
    
    scrutinio$liste_naz$PERCENTUALE <- 
      scrutinio$liste_naz$VOTI_LISTA / sum(scrutinio$liste_naz$VOTI_LISTA)
    
    scrutinio$liste_naz <- merge(
      scrutinio$liste_naz,
      aggregate(
        ELETTI ~ LISTA,
        scrutinio$liste_pluri,
        sum
      )
    )
    
    scrutinio$liste_naz <- merge(
      scrutinio$liste_naz,
      liste_naz[, c("LISTA", "CL", "ABBREV")]
    )
    
    scrutinio$candidati_uni <- merge(
      scrutinio$candidati_uni,
      dati$candidati_uni[, c("CANDIDATO", "CL")]
    )
    
    scrutinio$cl_naz <- aggregate(
      VOTI_LISTA ~ CL,
      scrutinio$liste_naz,
      sum
    )
    
    scrutinio$cl_naz$PERCENTUALE <- 
      scrutinio$cl_naz$VOTI_LISTA / sum(scrutinio$cl_naz$VOTI_LISTA)
    
    scrutinio$cl_naz <- merge(
      scrutinio$cl_naz,
      aggregate(
        ELETTI ~ CL,
        scrutinio$liste_naz,
        sum
      )
    )
    
    scrutinio$cl_naz <- merge(
      scrutinio$cl_naz,
      aggregate(
        ELETTO ~ CL,
        scrutinio$candidati_uni,
        sum
      )
    )
    
    scrutinio$cl_naz$ELETTI_TOT <- 
      scrutinio$cl_naz$ELETTI + scrutinio$cl_naz$ELETTO
    
    scrutinio$cl_naz <- scrutinio$cl_naz[order(
      scrutinio$cl_naz$CL
    ), ]
    
    scrutinio$candidati_pluri <- merge(
      scrutinio$candidati_pluri,
      liste_naz[, c("LISTA", "CL", "ABBREV")]
    )
    
    list(
      liste_pluri = scrutinio$liste_pluri,
      liste_naz = scrutinio$liste_naz,
      cl_naz = scrutinio$cl_naz,
      candidati_uni = scrutinio$candidati_uni,
      candidati_pluri = scrutinio$candidati_pluri
    )
  }
  
  cl <- makeCluster(parallel::detectCores())
  
  clusterEvalQ(
    cl,
    source("scrutinio.R")
  )
  
  lista_risultati <- parLapply(
    cl,
    seq_len(iterazioni),
    iterazione,
    ramo = ramo,
    dati = dati,
    liste_naz = liste_naz,
    variab = variab
  )
  
  stopCluster(cl)
  
  risultato <- list()
  
  risultato$liste_pluri <- 
    rbindlist(lapply(lista_risultati, function(l) l$liste_pluri), idcol = "SIM")
  risultato$liste_naz <- 
    rbindlist(lapply(lista_risultati, function(l) l$liste_naz), idcol = "SIM")
  risultato$cl_naz <- 
    rbindlist(lapply(lista_risultati, function(l) l$cl_naz), idcol = "SIM")
  risultato$candidati_uni <- 
    rbindlist(lapply(lista_risultati, function(l) l$candidati_uni), idcol = "SIM")
  risultato$candidati_pluri <- 
    rbindlist(lapply(lista_risultati, function(l) l$candidati_pluri), idcol = "SIM")
  
  lista_risultati <- NULL
  
  risultato
}

camera$risultato <- simula(
  "camera",
  iterazioni = iterazioni,
  variab = variab
)

senato$risultato <- simula(
  "senato",
  iterazioni = iterazioni,
  variab = variab
)
```

## Dati di input

```{r liste_naz}
library(kableExtra)
options(knitr.kable.NA = '')
liste_naz <- liste_naz[order(liste_naz$PERCENTUALE, decreasing = TRUE), ]
liste_naz$PERCENTUALE <- formattable::percent(liste_naz$PERCENTUALE, 1)
kbl(
  liste_naz[
    liste_naz$AREA != "astensione" & !is.na(liste_naz$COLORE), 
    c("LISTA", "PERCENTUALE", "COALIZIONE", "AREA")
  ],
  row.names = FALSE,
  col.names = c(
    "Lista",
    "Percentuale",
    "Coalizione",
    "Area"
  )
) %>%
  kable_minimal()
```

- Percentuali nazionali dal sondaggio `r altri_dati$Sondaggio`
- Numero di simulazioni effettuate: `r iterazioni`
- Parametro di variabilità dei voti: `r variab`

## Dettagli del procedimento

I collegi uninominali e plurinominali,
e il rispettivo numero di seggi,
sono stati ricavati dai Decreti del Presidente della Repubblica
del 21 luglio 2022.

I candidati sono stati ricavati da [Eligendo](https://dait.interno.gov.it/elezioni/trasparenza/elezioni-politiche-2022).

I voti di ogni lista in ciascun collegio uninominale sono stati stimati in
questo modo:

1. Sono stati recuperati i dati delle elezioni della Camera del 2018, delle
 elezioni europee del 2019 e delle elezioni regionali dal 2018 ad oggi.
2. Le liste (sia delle passate elezioni sia della futura elezione) sono state 
raggruppate in "aree politiche" (vedi tabella sopra), aggiungendo una ulteriore 
area "astensione".
3. Basandosi sui risultati delle elezioni precedenti, per ciascuna provincia è
stata stimata la percentuale di popolazione "appartenente" a ciascuna area 
politica.
4. Per ciascuna area politica è stata calcolata quindi la percentuale di 
popolazione di quella area politica presente nella provincia, rispetto al totale
nazionale, cioè è stata calcolata la distribuzione geografica di ogni area 
politica.
5. Per ciascuna area politica, i voti nazionali (calcolati in base alle 
percentuali del sondaggio mostrate nella tabella sopra) sono stati divisi nelle 
diverse provincie in base alla distribuzione calcolata al punto 4.
6. Sono state calcolate le percentuali di ogni area all'interno di ogni 
provincia, rispetto al totale di voti assegnati a ogni provincia.
7. A partire dalle percentuali del punto 6 sono state calcolate le percentuali
di ogni area all'interno di ogni collegio uninominale di Camera e Senato, in 
base a quali comuni di quali provincie appartengono a ciascun collegio.
8. In ogni collegio, le percentuali di ciascuna area sono state suddivise tra le
liste di quell'area proporzionalmente alla percentuale nazionale (da sondaggio) 
di ciascuna lista.

Se qualcuno ha a disposizione stime più precise delle percentuali su base
locale, le integro volentieri della simulazione.

Sono state effettuate `r iterazioni` simulazioni, in ciascuna delle quali la 
percentuale di ciascuna lista in ciascun collegio è stata fatta variare un poco 
rispetto alla percentuale calcolata nel punto 8. Il parametro di variabilità
stabilisce quanto i voti possono variare (per i dettagli del calcolo, vedere
gli script).

Una volta ottenuti i voti per ciascun collegio, sono stati applicati
alla lettera il DPR 361/57 e il D.Lgs. 533/93 (con l'unica eccezione dei casi
di parità da risolvere con sorteggio, e per il Senato applicando, in caso di 
incapienza di una lista, quanto
accaduto a seguito delle elezioni 2018, cioè
andando a ripescare candidati non eletti anche da altre regioni).

**Non sono stati simulati i seggi delle circoscrizioni Estero e Valle d'Aosta.**

**Sto trascurando SVP, 
dunque i risultati, 
soprattutto per il Trentino-Alto Adige,
potrebbero essere falsati**

Gli script per l'esecuzione dell'analisi si trovano in questo repository:
<https://github.com/fornaeffe/elezioni>

L'analisi è stata svolta con `r R.version.string`.

## Risultati

```{r prep_grafici}
liste_naz$COL <- "#DDDDDD"
liste_naz$COL[!is.na(liste_naz$COLORE)] <- 
    hsv(liste_naz$COLORE[!is.na(liste_naz$COLORE)] / 360, 1, .8, 1)

camera$risultato$liste_naz <- merge(
  camera$risultato$liste_naz,
  liste_naz[, c("LISTA", "COL")]
)
senato$risultato$liste_naz <- merge(
  senato$risultato$liste_naz,
  liste_naz[, c("LISTA", "COL")]
)

camera$risultato$cl_naz <- merge(
    camera$risultato$cl_naz,
    liste_naz[!duplicated(liste_naz$CL), c("CL", "COL")]
  )
senato$risultato$cl_naz <- merge(
    senato$risultato$cl_naz,
    liste_naz[!duplicated(liste_naz$CL), c("CL", "COL")]
  )
```

Nei grafici seguenti è mostrata la composizione mediana dei due rami del
Parlamento.

I seggi attribuiti attraverso il sistema maggioritario nei collegi 
**uninominali** sono indicati con **"Magg."** seguito dal nome della 
**coalizione**.

I seggi attribuiti attraverso il sistema proporzionale nei collegi
**plurinominali** sono indicati con **"Prop."** seguito dal nome della
**lista**.

Nota: poiché per ogni coalizione o lista è stato preso il valore mediano
tra tutte le simulazioni,
e i valori di ciascuna coalizione o lista
potrebbero non provenire dalla stessa simulazione,
il totale dei seggi potrebbe essere leggermente differente
da 400 (nel caso della Camera) o 200 (nel caso del Senato).

```{r plot_parlamento}
library(ggplot2)
library(ggpol)

disegna_parlamento <- function(ramo) {
  dati <- get(ramo)
  uni <- aggregate(
    ELETTO ~ CL,
    dati$risultato$cl_naz,
    median,
    subset = CL %in% liste_naz$CL[!is.na(liste_naz$COLORE)]
  )
  
  uni$SEGGI <- uni$ELETTO
  uni <- merge(
    uni,
    liste_naz[!duplicated(liste_naz$CL), c("CL", "COLORE")]
  )
  uni$COL <- hsv(uni$COLORE / 360, 1, 1, 1)
  uni$Gruppo <- paste("Magg.", uni$CL)
  
  pluri <- aggregate(
    ELETTI ~ ABBREV,
    dati$risultato$liste_naz,
    median,
    subset = ABBREV %in% liste_naz$ABBREV[!is.na(liste_naz$COLORE)]
  )
  pluri$SEGGI <- pluri$ELETTI
  pluri <- merge(
    pluri,
    liste_naz[, c("ABBREV", "COL", "CL")]
  )
  pluri <- pluri[order(pluri$CL), ]
  pluri$Gruppo <- paste("Prop.", pluri$ABBREV)
  
  parlamento <- rbind(
    uni[, c("Gruppo", "SEGGI", "COL")],
    pluri[, c("Gruppo", "SEGGI", "COL")],
    data.frame(
      Gruppo = c("Valle d'Aosta", "Estero"),
      SEGGI = c(1, ifelse(ramo == "camera", 8, 4)),
      COL = c("#AAAAAAFF", "#808080FF")
    )
  )
  
  # Evito seggi con valore di 0.5
  parlamento$SEGGI <- ceiling(parlamento$SEGGI)
  
  parlamento <- parlamento[parlamento$SEGGI > 0, ]
  
  ggplot(parlamento) +
    geom_parliament(aes(seats = SEGGI, fill = Gruppo), color = "black") +
    scale_fill_manual(values = parlamento$COL, labels = paste(
      parlamento$Gruppo,
      "-",
      parlamento$SEGGI
    )) +
    coord_fixed() +
    theme_void()
}


```

### Composizione media della Camera
```{r}
disegna_parlamento("camera")
```

### Composizione media del Senato
```{r}
disegna_parlamento("senato")
```

### Probabilità di superare la soglia

```{r}
superamento_soglia <- function(ramo) {
  eletti <- aggregate(
    ELETTO ~ ABBREV + SIM,
    get(ramo)$risultato$candidati_pluri,
    sum,
    subset = LISTA %in% liste_naz$LISTA[!is.na(liste_naz$COLORE)]
  )
  eletti$SOGLIA <- eletti$ELETTO > 0
  soglie <- aggregate(
    SOGLIA ~ ABBREV,
    eletti,
    mean
  )
  soglie$SOGLIA <- formattable::percent(soglie$SOGLIA, 0)
  kbl(
    soglie,
    col.names = c("LISTA", "Prob. di eleggere da coll. plurin."),
    caption = ramo
  ) %>%
    kable_minimal()
}

superamento_soglia("camera")
superamento_soglia("senato")

```


### Eletti rispetto alla percentuale

Nei grafici seguenti è mostrato il numero di eletti (rispettivamente totali,
nei collegi uninominali e nei collegi plurinominali) per ciascuna coalizione o 
ciascuna lista, a seconda della percentuale di voti ottenuta dalla coalizione o
lista. Ogni punto rappresenta una diversa simulazione, i punti relativi a una
coalizione o una lista formano una "nuvola" perché in ciascuna 
simulazione la percentuale è libera di variare leggermente rispetto alla
percentuale stimata dai sondaggi, e di conseguenza la coalizione o la lista
ottiene un numero più o meno alto di seggi.

La linea orizzontale punteggiata rappresenta la metà dei seggi (esclusi quelli
di Val d'Aosta ed Estero, che non sono stati simulati).

```{r plot_eletti_tot}
#| fig.width: 8
#| fig-height: 8
#| dpi: 100


layout(matrix(1:4, 2, 2), c(5, 3), c(5, 5))
par(mar = c(4,4,4,2) )
plot(
  ELETTI_TOT ~ I(PERCENTUALE * 100),
  data = camera$risultato$cl_naz,
  col = COL,
  main = "Camera: eletti totali",
  xlab = "Percentuale",
  ylab = "Eletti"
)
abline(h = 391 / 2, lty = "dotted")
plot(
  ELETTI_TOT ~ I(PERCENTUALE * 100),
  data = senato$risultato$cl_naz,
  col = COL,
  main = "Senato: eletti totali",
  xlab = "Percentuale",
  ylab = "Eletti"
)
abline(h = 195 / 2, lty = "dotted")

par(mar = c(4,0.1,4,0.1) )
plot(NA, xlim = c(0,1), ylim = c(0,1), axes=FALSE, xlab="", ylab="")
legend(
  "topleft",
  legend = liste_naz$CL[!is.na(liste_naz$COLORE) & !duplicated(liste_naz$CL)],
  pch = 19,
  col = liste_naz$COL[!is.na(liste_naz$COLORE) & !duplicated(liste_naz$CL)]
)
plot(NA, xlim = c(0,1), ylim = c(0,1), axes=FALSE, xlab="", ylab="")
legend(
  "topleft",
  legend = liste_naz$CL[!is.na(liste_naz$COLORE) & !duplicated(liste_naz$CL)],
  pch = 19,
  col = liste_naz$COL[!is.na(liste_naz$COLORE) & !duplicated(liste_naz$CL)]
)


```
\
\
\

```{r plot_eletti_uni}
#| fig.width: 8
#| fig-height: 8
#| dpi: 100

layout(matrix(1:4, 2, 2), c(5, 3), c(5, 5))
par(mar = c(4,4,4,2) )
plot(
  ELETTO ~ I(PERCENTUALE * 100),
  data = camera$risultato$cl_naz,
  col = COL,
  main = "Camera: eletti nei collegi uninominali",
  xlab = "Percentuale",
  ylab = "Eletti"
)
abline(h = nrow(camera$collegi_uni) / 2, lty = "dotted")
plot(
  ELETTO ~ I(PERCENTUALE * 100),
  data = senato$risultato$cl_naz,
  col = COL,
  main = "Senato: eletti nei collegi uninominali",
  xlab = "Percentuale",
  ylab = "Eletti"
)
abline(h = nrow(senato$collegi_uni) / 2, lty = "dotted")

par(mar = c(4,0.1,4,0.1) )
plot(NA, xlim = c(0,1), ylim = c(0,1), axes=FALSE, xlab="", ylab="")
legend(
  "topleft",
  legend = liste_naz$CL[!is.na(liste_naz$COLORE) & !duplicated(liste_naz$CL)],
  pch = 19,
  col = liste_naz$COL[!is.na(liste_naz$COLORE) & !duplicated(liste_naz$CL)]
)
plot(NA, xlim = c(0,1), ylim = c(0,1), axes=FALSE, xlab="", ylab="")
legend(
  "topleft",
  legend = liste_naz$CL[!is.na(liste_naz$COLORE) & !duplicated(liste_naz$CL)],
  pch = 19,
  col = liste_naz$COL[!is.na(liste_naz$COLORE) & !duplicated(liste_naz$CL)]
)


```
\
\
\

```{r plot_eletti_pluri}
#| fig.width: 8
#| fig-height: 8
#| dpi: 100

layout(matrix(1:4, 2, 2), c(5, 3), c(5, 5))
par(mar = c(4,4,4,2) )
plot(
    ELETTI ~ I(PERCENTUALE * 100),
    data = camera$risultato$liste_naz,
    col = COL,
    main = "Camera: eletti nei collegi plurinominali",
    xlab = "Percentuale",
    ylab = "Eletti"
  )
plot(
    ELETTI ~ I(PERCENTUALE * 100),
    data = senato$risultato$liste_naz,
    col = COL,
    main = "Senato: eletti nei collegi plurinominali",
    xlab = "Percentuale",
    ylab = "Eletti"
  )

par(mar = c(4,0.1,4,0.1) )
plot(NA, xlim = c(0,1), ylim = c(0,1), axes=FALSE, xlab="", ylab="")
legend(
  "topleft",
  legend = liste_naz$ABBREV[!is.na(liste_naz$COLORE)],
  pch = 19,
  col = liste_naz$COL[!is.na(liste_naz$COLORE)]
)
plot(NA, xlim = c(0,1), ylim = c(0,1), axes=FALSE, xlab="", ylab="")
legend(
  "topleft",
  legend = liste_naz$ABBREV[!is.na(liste_naz$COLORE)],
  pch = 19,
  col = liste_naz$COL[!is.na(liste_naz$COLORE)]
)


```
\
\
\



```{r}
library(stringr)
disegna_tabella_uni <- function(ramo) {
  tbl <- reshape(
    aggregate(
      ELETTO ~ 
        COLLEGIOUNINOMINALE +
        CL,
      get(ramo)$risultato$candidati_uni,
      mean,
      subset = CL %in% liste_naz$CL[!is.na(liste_naz$COLORE)]
    ),
    direction = "wide",
    idvar = "COLLEGIOUNINOMINALE",
    timevar = "CL"
  )
  names(tbl) <- str_remove(names(tbl), "ELETTO\\.")
  tbl[is.na(tbl)] <- 0
  
  kb <- kbl(tbl, row.names = FALSE) %>%
    kable_minimal()
  
  for (i in 2:ncol(tbl)) {
    kb <- column_spec(
      kb,
      i,
      background = hsv(
        liste_naz$COLORE[liste_naz$CL == names(tbl)[i]][1] / 360, 
        .65, 
        1, 
        tbl[[i]]
      )
    )
  }
  
  kb
}

disegna_tabella_pluri <- function(ramo) {
  tbl <- reshape(
    aggregate(
      ELETTI ~ CIRCOSCRIZIONE + COLLEGIOPLURINOMINALE + ABBREV,
      get(ramo)$risultato$liste_pluri,
      mean,
      subset = ABBREV %in% liste_naz$ABBREV[!is.na(liste_naz$COLORE)]
    ),
    direction = "wide",
    idvar = c("CIRCOSCRIZIONE", "COLLEGIOPLURINOMINALE"),
    timevar = "ABBREV"
  )
  names(tbl) <- str_remove(names(tbl), "ELETTI\\.")
  
  kb <- kbl(
    tbl,
    row.names = FALSE
  ) %>%
    kable_minimal()
  
  for (i in 3:ncol(tbl)) {
    kb <- column_spec(
      kb,
      i,
      background = hsv(
        liste_naz$COLORE[which(liste_naz$ABBREV == names(tbl)[i])] / 360, 
        1, 
        1, 
        tbl[[i]] / 4
      )
    )
  }
  kb
}

```

### Probabilità di vittoria in ciascun collegio uninominale della **Camera**
Nella tabella seguente, per ciascun collegio uninominale, è mostrata la 
probabilità di vittoria di ciascuna coalizione.

```{r}
disegna_tabella_uni("camera")
```
\
\
\

### Probabilità di vittoria in ciascun collegio uninominale del **Senato**
Nella tabella seguente, per ciascun collegio uninominale, è mostrata la 
probabilità di vittoria di ciascuna coalizione.

```{r}
disegna_tabella_uni("senato")
```
\
\
\
\

### Probabilità di elezione per ciascuna posizione nei collegi plurinominali

Nelle tabelle seguenti, per ciascuna lista e per ciascun ramo del Parlamento,
è indicata la probabilità di elezione per il candidato in prima,
seconda, terza e quarta posizione.

```{r results='asis'}
disegna_tabella_prob <- function(ramo, lista) {
  lp <- get(ramo)$risultato$liste_pluri
  lp <- lp[lp$LISTA == lista, ]
  lp$NUMERO_MAX <- factor(lp$NUMERO_MAX, levels = 0:4)
  tbl <- table(lp$COLLEGIOPLURINOMINALE, lp$NUMERO_MAX)
  tbl2 <- t(apply(
    tbl,
    1,
    function(x) {
      rev(cumsum(rev(x[2:5]))) / sum(x)
    }
  ))
  
  tbl2 <- as.data.frame(tbl2)
  for (i in 1:4) {
    tbl2[,i] <- formattable::percent(tbl2[, i], 1)
  }
  
  kb <- kbl(tbl2, caption = paste(lista, ramo, sep = " - ")) %>%
    kable_minimal()
  
  for (i in 1:4) {
    kb <- column_spec(
      kb,
      i+1,
      background = hsv(
        liste_naz$COLORE[which(liste_naz$LISTA == lista)] / 360, 
        1, 
        1, 
        tbl2[,i]
      )
    )
  }
  kb
}


for (lista in liste_naz$LISTA[!is.na(liste_naz$COLORE)]) {
  print(disegna_tabella_prob("camera", lista))
  print(disegna_tabella_prob("senato", lista))
}

```

### Probabilità di elezione di ciascun candidato

Nelle tabelle seguente, per ciascun candidato,
è indicata la probabilità complessiva di elezione,
in una qualsiasi delle posizioni dove è candidato.

```{r}
disegna_tabella_candidati <- function(ramo) {
  dati <- get(ramo)
  candidati <- rbind(
    dati$risultato$candidati_uni[, c("SIM", "CL", "CANDIDATO", "ELETTO")],
    dati$risultato$candidati_pluri[, c("SIM", "CL", "CANDIDATO", "ELETTO")]
  )
  candidati <- aggregate(
    ELETTO ~ CANDIDATO + CL + SIM,
    candidati,
    function(x) Reduce("|", x)
  )
  candidati <- aggregate(
    ELETTO ~ CANDIDATO + CL,
    candidati,
    sum
  )
  candidati$ELETTO <- candidati$ELETTO / iterazioni
  candidati <- merge(
    candidati,
    liste_naz[!duplicated(liste_naz$CL) & !is.na(liste_naz$COLORE), c("CL", "COLORE")]
  )
  candidati <- merge(
    candidati,
    unique(dati$candidati_pluri[, c("CANDIDATO", "ABBREV")]),
    all.x = TRUE
  )
  candidati <- merge(
    candidati,
    liste_naz[!is.na(liste_naz$COLORE), c("ABBREV", "COLORE")],
    by = "ABBREV",
    all.x = TRUE,
    suffixes = c("", "_ABBREV")
  )
  candidati$CL[!is.na(candidati$ABBREV)] <- 
    candidati$ABBREV[!is.na(candidati$ABBREV)]
  candidati$COLORE[!is.na(candidati$ABBREV)] <- 
    candidati$COLORE_ABBREV[!is.na(candidati$ABBREV)]
  candidati$ABBREV <- NULL
  candidati$COLORE_ABBREV <- NULL
  candidati$ELETTO <- formattable::percent(candidati$ELETTO, 0)
  
  candidati <- candidati[
    order(
      candidati$CL,
      candidati$ELETTO,
      decreasing = c(FALSE, TRUE),
      method = "radix"
    ), 
  ]
  kbl(
    candidati[1:3],
    col.names = c(
      "Candidato",
      "Lista/Coalizione",
      "Probabilità di elezione"
    ),
    row.names = FALSE,
    caption = ramo
  ) %>%
    kable_minimal() %>%
    column_spec(
      3,
      background = hsv(
        candidati$COLORE / 360, 
        1, 
        1, 
        candidati$ELETTO
      )
    )
}

disegna_tabella_candidati("camera")
disegna_tabella_candidati("senato")
```



